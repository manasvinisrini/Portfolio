---
layout: page
title: Boeing Project - Part II
subtitle: Northwestern University&#58; MSR Final Project
---
	<h3>Technical Skills</h3>
	<ul>
        <li>3D CAD with Onshape</li>
        <li>PCB Design &amp; Soldering</li>
        <li>Crimping &amp; Wiring Design</li>
        <li>Programming the <a href="https://www.digikey.com/product-detail/en/texas-instruments/EK-TM4C123GXL/296-35760-ND/3996736" target="_blank">Tiva C Series microcontroller</a></li>
        <li>ROS Kinetic</li>
        <li>Mobile Robot Kinematics</li>
        <li>Ubuntu 16.04 LTS</li>
        <li>SLAM &amp; Sensor Fusion</li>
        <li>Python &amp; C/C++</li>
	  <li>Setting up the <a href="https://www.intel.com/content/www/us/en/products/boards-kits/nuc/kits/nuc7i7bnh.html"target="_blank">Intel NUC Kit NUC7i7BNH</a></li>
	</ul>
	<hr />
    <h3>Introduction</h3>
    <p>As mentioned on the Project page, this quarter brought forth some major changes, even some updates to the design proposed last quarter! For that reason, this post will attempt to describe the new build process of the Omni robot from the ground up, possibly overlapping from the last post but making up for it by explaining things in a sequential, easy to understand manner. That said, the goal of the project remained the same - to build and program three mobile platforms such that they are able to move as one rigid body. This is imperative as each platform will be carrying an inverted robotic delta arm (designed by Matthew Elwin and William Hunt) which in turn will be supporting part of a large rigid object. Without the platforms moving as one entity (i.e. in a formation), it will not be possible for the delta arms to maintain their hold on the rigid object. This is also why it is vital that the odometry calculated by each robot is as accurate as possible - to minimize drift that could ruin the formation. To accomplish this, there were five main tasks that were involved:</p>

    <figure style="text-align: center; float: right; font-style: italic; width: 30%; margin-left: 1%">
      <img src="images/sabertooth.png" style = "height: 275px;">
      <p>Figure 2: Sabertooth 2x25A V2</p>
    </figure>
    <figure style="text-align: center; float: right; font-style: italic; width: 30%;">
      <img src="images/motor.png" style= "height: 275px;">
      <p>Figure 1: IG52-04 24VDC 285 RPM motor</p>
    </figure>

    <ul>
        <li>Wiring &amp; PCB Design</li>
        <li>Programming the Tiva microcontrollers</li>
        <li>Physical Design &amp; Placement of Sensors</li>
        <li>Control of a Single Robot including Odometry Calculation &amp; Verification along with Sensor Fusion</li>
        <li>Formation Control of all Three Robots</li>
    </ul>
    <h3>Wiring &amp; PCB Design</h3>
    <p>This section provides a mid-level overview of how all the electronics were connected, starting from the motor and going all the way up to the sensors. Before starting, it should be noted that the motors, motor drivers, chassis, wheels, switches, batteries, gears and chains were all sourced from the <a href="https://www.superdroidrobots.com/shop/item.aspx/programmable-mecanum-wheel-vectoring-robot-ig52-db/1788/" target="_blank">Programmable Mecanum Wheel Vectoring Robot - IG52 DB</a> product on SuperDroid Robots' website. As shown in Figure 1, a brushed 24VDC motor, capable of going 285 RPM and complete with a dual channel/quadrature magnetic encoder was used for this project. Four of these were installed in the aluminum chassis with enough combined torque to move the robot while carrying a 200lb payload! In regards to connections, the Sabertooth motor driver (Figure 2) can provide 25A to two motors (one pair of red/black leads wired to M1A/M1B, and the other pair to M2A/M2B). As the motors have a rated current of up to 2.85A, this driver is more than able to do the job. The middle two terminals of the Sabertooth (B+/B-) were then wired to a 24V busbar (powered by two 12V 18Ah Interstate SLA batteries hooked up in series) via a 25A 4PST switch. For safety, a 6.3A Slow fuse was hooked up between B+ and the 24V (2.85A*2 < 6.3A). Since there are four motors, two Sabertooths were installed - one on either side of the robot.
    </p>
    <figure style="text-align: center; float: left; font-style: italic; width: 50%; margin-right: 2%">
      <img src="images/wheel_tiva.JPG" style = "width: 100%;">
      <p>Figure 3: 'Wheel' PCB to control the motors</p>
    </figure>
     <p>With a good understanding now of how the motors are powered, the wiring needed to control them can be discussed. In the previous paragraph, I mentioned that each motor has a quadrature encoder which can be used to measure its speed. Four wires come out from the encoder. Two of them represent Channel A and B and the other two provide 5V and Ground. Unfortunately, the Tiva microcontroller that is being used only has two quadrature encoder peripherals (aka QEI pins). As a result, only two motors' encoder wires can be hooked up to any one microcontroller. Thus, two PCBs were made to aid in the motor control process. Known as the 'Wheel Control Board' (shown in Figure 3), each board contains two four-pin JST housings for two sets of encoders (by the yellow heat-shrink in Figure 3). Additionally, it holds a three-pin JST housing (by the black heat-shrink) for three wires that connect to the 0V, 5V, and S1 pins on the Sabertooth (Figure 2). The Tiva microcontroller (which plugs into the header pins on the left half of the board) uses these three pins to send packetized serial commands to the Sabertooth. The 0V pin provides a ground reference for the signal pin (S1), and due to how the <a href="https://www.dimensionengineering.com/datasheets/Sabertooth2x25v2.pdf" target="_blank">packetized serial mode</a> works on the Sabertooth, the Tiva can send commands via the S1 pin to both of the motors hooked up to the Sabertooth. Finally, in order to isolate the 'high voltage' motor driver from the 'low voltage' Tiva board, the <a href="https://www.digikey.com/product-detail/en/texas-instruments/ISO3086DWR/296-41273-1-ND/5222737" target="_blank">ISO3086DWR</a> 16-pin isolated RS485 chip was placed between them. The 'high' 5V from the Sabertooth was then used to power the 'high' side of the chip.
    </p>
    <figure style="text-align: center; float: right; font-style: italic; width: 50%; margin-left: 2%">
      <img src="images/omni_tiva.JPG" style = "width: 100%;">
      <p>Figure 4: 'Omni' PCB to control the 'Wheel' microcontrollers</p>
    </figure>
    <p>Technically, this setup would have been enough to control all four wheels of the robot. An FTDI cable could be hooked up from each Tiva microcontroller (TX, RX, and ground pins) to the NUC (a computer with a 4x4 inch footprint capable of running Ubuntu Linux) and the NUC could send commands through it to both microcontrollers. However, this design idea was discarded for a few reasons: 1) it would require twice the number of USB ports on the NUC 2) there was no guarantee that commands would be sent to each 'Wheel' Tiva at exactly the same time 3) since the Delta robot had a 'master' microcontroller to control the Tivas that directly interfaced with its motors, it would be consistent if the Omni robot had one as well. This is where the Ethernet cables come in handy. As shown in the right part of Figure 4, two Ethernet cables leave the 'Omni' PCB from the two silver rectangular ports. One cable connects to a port on one 'Wheel' PCB (top right in Figure 3) and the other connects to the second 'Wheel PCB'. In order to preserve Serial data, 8-pin RS485 chips (one for each 'Wheel' PCB and two on the 'Omni' PCB) were placed in between the TX and RX pins of the Tiva and the Ethernet port. This accounts for four of the wires inside the 8-wire bundle that make up the Ethernet cable (TX+, TX-, RX+, RX-). Another two wires provide 5V and GND to power the 'Wheel' Tivas. The last two wires were used for Emergency Stop purposes - one for a 'Wheel' Tiva to request an E-STOP (from the 'master' Tiva) and one to get back the response. The 'requests' then become two inputs to an AND gate on the 'Omni' PCB. Another two inputs to the AND gate come from the 'Omni' Tiva itself as well as an external Emergency Stop button (which plugs into the two pin JST in the top of Figure 4). If the Delta robot is being run at the same time as the Omni robot, the output of the AND gate travels up (via the 4-pin JST right next to the two-pin E-STOP JST) to the Delta and becomes an input to another AND gate located on <i>its</i> 'master' PCB. The output from the Delta AND gate (i.e. the 'response') travels back down to the 'Omni' PCB then to the 'Wheel' PCBs. However, if the Delta robot is not connected, the output of the AND gate located on the 'Omni' PCB becomes the 'response' signal (thus, the reason why the 4-pin JST shows a wire looping back on itself - note that the other two pins of that JST do not connect to anything). Finally, the black FTDI cable shown in Figure 4 connects to a USB port in the NUC.
    </p>
    <p>Besides for the 'Omni' FTDI cable, three other micro-USB cables plug into the NUC. One is used to power the 'Omni' Tiva (which then feeds the power to the 'Wheel' Tivas). The other two plug into <a href="https://www.hokuyo-aut.jp/search/single.php?serial=166" target="_blank">this</a> laser scanner and <a href="https://www.digikey.com/product-detail/en/sparkfun-electronics/SEN-14001/1568-1460-ND/6569364" target="_blank">this</a> IMU respectively. To power the NUC though is a bigger problem since it only accepts 12-19VDC and because it should be isolated from the 24V motor power supply. To fix this issue, <a href="https://www.mouser.com/ProductDetail/Cincon/CHB100W-24S15-CM?qs=sGAEpiMZZMvGsmoEFRKS8K1E1cjl%252byI1KuVMoGoVhIfkFKyYYc59Rw%3d%3d" target="_blank">this DC/DC converter</a> was placed between the NUC and the 24V motor power supply (can partially be seen under the 'Omni' PCB in Figure 4). In any event, that about sums up the wiring of the Omni robot!
    </p>
    <h3>Programming the Tiva Microcontroller</h3>
    <p>With an ARM Cortex-M4 core capable of floating point, CPU speeds up to 80 MHz, 256KB Flash memory, 2KB EEPROM, 8 UART modules, 2 Quadrature Encoder Inputs, and a pricetag of only $13.50, the TM4C123G LaunchPad Evaluation Board had everything needed to make this project work. Although in the design from last quarter, the plan was to have each Sabertooth connected to a <a href="https://www.superdroidrobots.com/shop/item.aspx?itemid=1514" target="_blank">Kangaroo motion controller</a> which in turn would be wired to a single Arduino Mega, this was rejected for a couple of reasons. For one, the Kangaroo (which would have been responsible for doing PID control to maintain the desired wheel speeds) could not accurately measure the velocity of a given motor. For example, if the Kangaroo was commanded to rotate a motor at 60 rpm, an external tachometer would measure a speed of 55 rpm. A possible explanation for this could be due to the nature of the magnetic encoders on the back of each motor. Normally, Channel A and B should have a 90 degree phase shift between them as shown in Figure 5.
    </p>
    <figure style="text-align: center; float: left; font-style: italic; width: 30%; margin-right: 2%">
      <img src="images/encoder_trace.png" style = "width: 100%;">
      <p>Figure 5: Typical Encoder Trace</p>
    </figure>
    <p> However, when measured with an oscilloscope, the traces from the magnetic encoders showed variable phase shifts - some much less than 90 degrees (ex. if the Channel B trace in Figure 5 was shifted a bit more to the left). Considering the fact that the Kangaroo is designed to read traces with 4x encoding, it is possible then that it registered the leading edge of Channel A but missed the leading edge of Channel B since they were too close in time. This is further evidenced by the fact that the Kangaroo can only process 80,000 pulses/sec which is relatively slow compared to the Tiva microcontroller which can process pulses up to 20 MHz (which is fast enough so that even variable phase shifts don't make a difference). For that reason, it was decided to use the Tiva LaunchPads as a replacement for the Kangaroos (also because the Delta was using them). As such, it didn't make sense to keep using the Arduino Mega but rather to use another Tiva as the 'master' of the two 'Wheel' Tivas to keep the architecture consistent (and cheaper!).
    </p>
    <p>To actually program the Tiva microcontrollers, the Atom text editor was used in conjunction with the GNU Arm Embedded Toolchain so that programs could be flashed to them. In addition, my advisor (Matthew Elwin) provided libraries containing custom Serial communication protocols and basic peripheral initialization functions that he wrote (originally for the Delta robot) for my partner (Aamir Hussain) and I to use while developing our code. For the first couple weeks of the quarter, we both familiarized ourselves with his code as well as his style of programming so that we could program the microcontrollers for the Omni robot in a similar fashion. Additionally, in order to keep communication between the NUC, microcontrollers, and motors straightforward, it was decided to only allow 'upstream' systems to initiate contact. Specifically, the NUC could send commands down to the 'Omni' Tiva which in turn could send commands down to the 'Wheel' Tivas which in turn could send commands to the motors. However, a 'Wheel' Tiva would not be allowed to send data to the 'Omni' Tiva without first being requested to do so by the 'Omni' Tiva. Likewise, the 'Omni' Tiva would not be able to send data to the NUC without the NUC first requesting it. In any event, after becoming familiar with the microcontrollers, I focused on programming the 'Wheel' Tivas - specifically setting up the QEI peripherals mentioned above, creating a library of functions to interface with the Sabertooths (via packetized serial mode described <a href="https://www.dimensionengineering.com/datasheets/Sabertooth2x25v2.pdf" target="_blank">here</a>), and implementing a PID control loop to set wheel speeds. On the other hand, Aamir focused on programming the 'Omni' Tiva - specifically figuring out how to send Serial commands to both 'Wheel' Tivas at the same time as well as implementing functions to convert wheel velocities into twists and visa versa. This will be discussed more in the next paragraph.
    </p>
