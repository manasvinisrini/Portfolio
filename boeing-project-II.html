---
layout: page
title: Boeing Project - Part II
subtitle: Northwestern University&#58; MSR Final Project
---
	<h3>Technical Skills</h3>
	<ul>
        <li>3D CAD with Onshape</li>
        <li>PCB Design &amp; Soldering</li>
        <li>Crimping &amp; Wiring Design</li>
        <li>Programming the <a href="https://www.digikey.com/product-detail/en/texas-instruments/EK-TM4C123GXL/296-35760-ND/3996736" target="_blank">Tiva C Series microcontroller</a></li>
        <li>ROS Kinetic</li>
        <li>Mobile Robot Kinematics</li>
        <li>Ubuntu 16.04 LTS</li>
        <li>SLAM &amp; Sensor Fusion</li>
        <li>Python &amp; C/C++</li>
	  <li>Setting up the <a href="https://www.intel.com/content/www/us/en/products/boards-kits/nuc/kits/nuc7i7bnh.html"target="_blank">Intel NUC Kit NUC7i7BNH</a></li>
	</ul>
	<hr />
    <h3>Introduction</h3>
    <p>As mentioned on the Project page, this quarter brought forth some major changes, even some updates to the design proposed last quarter! For that reason, this post will attempt to describe the new build process of the Omni robot from the ground up, possibly overlapping from the last post but making up for it by explaining things in a sequential, easy to understand manner. That said, the goal of the project remained the same - to build and program three mobile platforms such that they are able to move as one rigid body. This is imperative as each platform will be carrying an inverted robotic delta arm (designed by Matthew Elwin and William Hunt) which in turn will be supporting part of a large rigid object. Without the platforms moving as one entity (i.e. in a formation), it will not be possible for the delta arms to maintain their hold on the rigid object. This is also why it is vital that the odometry calculated by each robot is as accurate as possible - to minimize drift that could ruin the formation. To accomplish this, there were five main tasks that were involved:</p>

    <figure style="text-align: center; float: right; font-style: italic; width: 30%; margin-left: 1%">
      <img src="images/sabertooth.png" style = "height: 275px;">
      <p>Figure 2: Sabertooth 2x25A V2</p>
    </figure>
    <figure style="text-align: center; float: right; font-style: italic; width: 30%;">
      <img src="images/motor.png" style= "height: 275px;">
      <p>Figure 1: IG52-04 24VDC 285 RPM motor</p>
    </figure>

    <ul>
        <li>Wiring &amp; PCB Design</li>
        <li>Programming the Tiva microcontrollers</li>
        <li>Physical Design &amp; Placement of Sensors</li>
        <li>Control of a Single Robot including Odometry Calculation &amp; Verification along with Sensor Fusion</li>
        <li>Formation Control of all Three Robots</li>
    </ul>
    <h3>Wiring &amp; PCB Design</h3>
    <p>This section provides a mid-level overview of how all the electronics were connected, starting from the motor and going all the way up to the sensors. Before starting, it should be noted that unless otherwise stated, all parts were sourced from the <a href="https://www.superdroidrobots.com/shop/item.aspx/programmable-mecanum-wheel-vectoring-robot-ig52-db/1788/" target="_blank">Programmable Mecanum Wheel Vectoring Robot - IG52 DB</a> product on SuperDroid Robots' website. As shown in Figure 1, a brushed 24VDC motor, capable of going 285 RPM and complete with a dual channel/quadrature magnetic encoder was used for this project. Four of these were installed in the aluminum chassis with enough combined torque to move the robot while carrying a 200lb payload! In regards to connections, the Sabertooth motor driver (Figure 2) can provide 25A to two motors (one pair of red/black leads wired to M1A/M1B, and the other pair to M2A/M2B). As the motors have a rated current of up to 2.85A, this driver is more than able to do the job. The middle two terminals of the Sabertooth (B+/B-) were then wired to a 24V busbar (powered by two 12V 18Ah Interstate SLA batteries hooked up in series) via a 25A 4PST switch. For safety, a 6.3A Slow fuse was hooked up between B+ and the 24V (2.85A*2 < 6.3A). Since there are four motors, two Sabertooths were installed - one on either side of the robot.
    </p>
    <figure style="text-align: center; float: left; font-style: italic; width: 50%; margin-right: 2%">
      <img src="images/wheel_tiva.JPG" style = "width: 100%;">
      <p>Figure 3: 'Wheel' PCB to control the motors</p>
    </figure>
     <p>With a good understanding now of how the motors are powered, the wiring needed to control them can be discussed. In the previous paragraph, I mentioned that each motor has a quadrature encoder which can be used to measure its speed. Four wires come out from the encoder. Two of them represent Channel A and B and the other two provide 5V and Ground. Unfortunately, the Tiva microcontroller that is being used only has two quadrature encoder peripherals (aka QEI pins). As a result, only two motors' encoder wires can be hooked up to any one microcontroller. Thus, two PCBs were made to aid in the motor control process. Known as the 'Wheel Control Board' (shown in Figure 3), each board contains two four-pin JST housings for two sets of encoders (by the yellow heat-shrink in Figure 3). Additionally, it holds a three-pin JST housing (by the black heat-shrink) for three wires that connect to the 0V, 5V, and S1 pins on the Sabertooth (Figure 2). The Tiva microcontroller (which plugs into the header pins on the left half of the board) uses these three pins to send packetized serial commands to the Sabertooth. The 0V pin provides a ground reference for the signal pin (S1), and due to how the <a href="https://www.dimensionengineering.com/datasheets/Sabertooth2x25v2.pdf" target="_blank">packetized serial mode</a> works on the Sabertooth, the Tiva can send commands via the S1 pin to both of the motors hooked up to the Sabertooth. Finally, in order to isolate the 'high voltage' motor driver from the 'low voltage' Tiva board, the <a href="https://www.digikey.com/product-detail/en/texas-instruments/ISO3086DWR/296-41273-1-ND/5222737" target="_blank">ISO3086DWR</a> 16-pin isolated RS485 chip was placed between them. The 'high' 5V from the Sabertooth was then used to power the 'high' side of the chip.
    </p>
    <figure style="text-align: center; float: right; font-style: italic; width: 50%; margin-left: 2%">
      <img src="images/omni_tiva.JPG" style = "width: 100%;">
      <p>Figure 4: 'Omni' PCB to control the 'Wheel' microcontrollers</p>
    </figure>
    <p>Technically, this setup would have been enough to control all four wheels of the robot. An FTDI cable could be hooked up from each Tiva microcontroller (TX, RX, and ground pins) to the NUC (a computer with a 4x4 inch footprint capable of running Ubuntu Linux) and the NUC could send commands through it to both microcontrollers. However, this design idea was discarded for a few reasons: 1) it would require twice the number of USB ports on the NUC 2) there was no guarantee that commands would be sent to each 'Wheel' Tiva at exactly the same time 3) since the Delta robot had a 'master' microcontroller to control the Tivas that directly interfaced with its motors, it would be consistent if the Omni robot had one as well. This is where the Ethernet cables come in handy. As shown in the right part of Figure 4, two Ethernet cables leave the 'Omni' PCB from the two silver rectangular ports. One cable connects to a port on one 'Wheel' PCB (top right in Figure 3) and the other connects to the second 'Wheel PCB'. In order to preserve Serial data, 8-pin RS485 chips (one for each 'Wheel' PCB and two on the 'Omni' PCB) were placed in between the TX and RX pins of the Tiva and the Ethernet port. This accounts for four of the wires inside the 8-wire bundle that make up the Ethernet cable (TX+, TX-, RX+, RX-). Another two wires provide 5V and GND to power the 'Wheel' Tivas. The last two wires were used for Emergency Stop purposes - one for a 'Wheel' Tiva to request an E-STOP (from the 'master' Tiva) and one to get back the response. The 'requests' then become two inputs to an AND gate on the 'Omni' PCB. Another two inputs to the AND gate come from the 'Omni' Tiva itself as well as an external Emergency Stop button (which plugs into the two pin JST in the top of Figure 4). If the Delta robot is being run at the same time as the Omni robot, the output of the AND gate travels up (via the 4-pin JST right next to the two-pin E-STOP JST) to the Delta and becomes an input to another AND gate located on <i>its</i> 'master' PCB. The output from the Delta AND gate (i.e. the 'response') travels back down to the 'Omni' PCB then to the 'Wheel' PCBs. However, if the Delta robot is not connected, the output of the AND gate located on the 'Omni' PCB becomes the 'response' signal (thus, the reason why the 4-pin JST shows a wire looping back on itself - note that the other two pins of that JST do not connect to anything). Finally, the black FTDI cable shown in Figure 4 connects to a USB port in the NUC.
    </p>
    <p>Besides for the 'Omni' FTDI cable, three other micro-USB cables plug into the NUC. One is used to power the 'Omni' Tiva (which then feeds the power to the 'Wheel' Tivas). The other two plug into <a href="https://www.hokuyo-aut.jp/search/single.php?serial=166" target="_blank">this</a> laser scanner and <a href="https://www.digikey.com/product-detail/en/sparkfun-electronics/SEN-14001/1568-1460-ND/6569364" target="_blank">this</a> IMU respectively. To power the NUC though is a bigger problem since it only accepts 12-19VDC and because it should be isolated from the 24V motor power supply. To fix this issue, <a href="https://www.mouser.com/ProductDetail/Cincon/CHB100W-24S15-CM?qs=sGAEpiMZZMvGsmoEFRKS8K1E1cjl%252byI1KuVMoGoVhIfkFKyYYc59Rw%3d%3d" target="_blank">this DC/DC converter</a> was placed between the NUC and the 24V motor power supply (can partially be seen under the 'Omni' PCB in Figure 4). In any event, that about sums up the wiring of the Omni robot!
    </p>
