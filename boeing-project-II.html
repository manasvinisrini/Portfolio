---
layout: page
title: Boeing Project - Part II
subtitle: Northwestern University&#58; MSR Final Project
---
	<h3>Technical Skills</h3>
	<ul>
        <li>3D CAD with Onshape</li>
        <li>PCB Design &amp; Soldering</li>
        <li>Crimping &amp; Wiring Design</li>
        <li>Programming the <a href="https://www.digikey.com/product-detail/en/texas-instruments/EK-TM4C123GXL/296-35760-ND/3996736" target="_blank">Tiva C Series microcontroller</a></li>
        <li>ROS Kinetic</li>
        <li>Mobile Robot Kinematics</li>
        <li>Ubuntu 16.04 LTS</li>
        <li>SLAM &amp; Sensor Fusion</li>
        <li>Python &amp; C/C++</li>
	  <li>Setting up the <a href="https://www.intel.com/content/www/us/en/products/boards-kits/nuc/kits/nuc7i7bnh.html"target="_blank">Intel NUC Kit NUC7i7BNH</a></li>
	</ul>
	<hr />
    <h3>Introduction</h3>
    <p>As mentioned on the Project page, this quarter brought forth some major changes, even some updates to the design proposed last quarter! For that reason, this post will attempt to describe the new build process of the Omni robot from the ground up, possibly overlapping from the last post but making up for it by explaining things in a sequential, easy to understand manner. That said, the goal of the project remained the same - to build and program three mobile platforms such that they are able to move as one rigid body. This is imperative as each platform will be carrying an inverted robotic delta arm (designed by Matthew Elwin and William Hunt) which in turn will be supporting part of a large rigid object. Without the platforms moving as one entity (i.e. in a formation), it will not be possible for the delta arms to maintain their hold on the rigid object. This is also why it is vital that the odometry calculated by each robot is as accurate as possible - to minimize drift that could ruin the formation. To accomplish this, there were five main tasks that were involved:</p>

    <figure style="text-align: center; float: right; font-style: italic; width: 30%; margin-left: 1%">
      <img src="images/sabertooth.png" style = "height: 275px;">
      <p>Figure 2: Sabertooth 2x25A V2</p>
    </figure>
    <figure style="text-align: center; float: right; font-style: italic; width: 30%;">
      <img src="images/motor.png" style= "height: 275px;">
      <p>Figure 1: IG52-04 24VDC 285 RPM motor</p>
    </figure>

    <ul>
        <li>Wiring &amp; PCB Design</li>
        <li>Programming the Tiva microcontrollers</li>
        <li>Physical Design &amp; Sensor Placement</li>
        <li>Control of a Single Robot including Odometry Calculation &amp; Verification along with Sensor Fusion</li>
        <li>Formation Control of all Three Robots</li>
    </ul>
    <h3>Wiring &amp; PCB Design</h3>
    <p>This section provides a mid-level overview of how all the electronics were connected, starting from the motor and going all the way up to the sensors. Before starting, it should be noted that the motors, motor drivers, chassis, wheels, switches, batteries, gears and chains were all sourced from the <a href="https://www.superdroidrobots.com/shop/item.aspx/programmable-mecanum-wheel-vectoring-robot-ig52-db/1788/" target="_blank">Programmable Mecanum Wheel Vectoring Robot - IG52 DB</a> product on SuperDroid Robots' website. As shown in Figure 1, a brushed 24VDC motor, capable of going 285 RPM and complete with a dual channel/quadrature magnetic encoder was used for this project. Four of these were installed in the aluminum chassis with enough combined torque to move the robot while carrying a 200lb payload! In regards to connections, the Sabertooth motor driver (Figure 2) can provide 25A to two motors (one pair of red/black leads wired to M1A/M1B, and the other pair to M2A/M2B). As the motors have a rated current of up to 2.85A, this driver is more than able to do the job. The middle two terminals of the Sabertooth (B+/B-) were then wired to a 24V busbar (powered by two 12V 18Ah Interstate SLA batteries hooked up in series) via a 25A 4PST switch. For safety, a 6.3A Slow fuse was hooked up between B+ and the 24V (2.85A*2 < 6.3A). Since there are four motors, two Sabertooths were installed - one on either side of the robot.
    </p>
    <figure style="text-align: center; float: left; font-style: italic; width: 50%; margin-right: 2%">
      <img src="images/wheel_tiva.JPG" style = "width: 100%;">
      <p>Figure 3: 'Wheel' PCB to control the motors</p>
    </figure>
     <p>With a good understanding now of how the motors are powered, the wiring needed to control them can be discussed. In the previous paragraph, I mentioned that each motor has a quadrature encoder which can be used to measure its speed. Four wires come out from the encoder. Two of them represent Channel A and B and the other two provide 5V and Ground. Unfortunately, the Tiva microcontroller that is being used only has two quadrature encoder peripherals (aka QEI pins). As a result, only two motors' encoder wires can be hooked up to any one microcontroller. Thus, two PCBs were made to aid in the motor control process. Known as the 'Wheel Control Board' (shown in Figure 3), each board contains two four-pin JST housings for two sets of encoders (by the yellow heat-shrink in Figure 3). Additionally, it holds a three-pin JST housing (by the black heat-shrink) for three wires that connect to the 0V, 5V, and S1 pins on the Sabertooth (Figure 2). The Tiva microcontroller (which plugs into the header pins on the left half of the board) uses these three pins to send packetized serial commands to the Sabertooth. The 0V pin provides a ground reference for the signal pin (S1), and due to how the <a href="https://www.dimensionengineering.com/datasheets/Sabertooth2x25v2.pdf" target="_blank">packetized serial mode</a> works on the Sabertooth, the Tiva can send commands via the S1 pin to both of the motors hooked up to the Sabertooth. Finally, in order to isolate the 'high voltage' motor driver from the 'low voltage' Tiva board, the <a href="https://www.digikey.com/product-detail/en/texas-instruments/ISO3086DWR/296-41273-1-ND/5222737" target="_blank">ISO3086DWR</a> 16-pin isolated RS485 chip was placed between them. The 'high' 5V from the Sabertooth was then used to power the 'high' side of the chip.
    </p>
    <figure style="text-align: center; float: right; font-style: italic; width: 50%; margin-left: 2%">
      <img src="images/omni_tiva.JPG" style = "width: 100%;">
      <p>Figure 4: 'Omni' PCB to control the 'Wheel' microcontrollers</p>
    </figure>
    <p>Technically, this setup would have been enough to control all four wheels of the robot. An FTDI cable could be hooked up from each Tiva microcontroller (TX, RX, and ground pins) to the NUC (a computer with a 4x4 inch footprint capable of running Ubuntu Linux) and the NUC could send commands through it to both microcontrollers. However, this design idea was discarded for a few reasons: 1) it would require twice the number of USB ports on the NUC 2) there was no guarantee that commands would be sent to each 'Wheel' Tiva at exactly the same time 3) since the Delta robot had a 'master' microcontroller to control the Tivas that directly interfaced with its motors, it would be consistent if the Omni robot had one as well. This is where the Ethernet cables come in handy. As shown in the right part of Figure 4, two Ethernet cables leave the 'Omni' PCB from the two silver rectangular ports. One cable connects to a port on one 'Wheel' PCB (top right in Figure 3) and the other connects to the second 'Wheel PCB'. In order to preserve Serial data, 8-pin RS485 chips (one for each 'Wheel' PCB and two on the 'Omni' PCB) were placed in between the TX and RX pins of the Tiva and the Ethernet port. This accounts for four of the wires inside the 8-wire bundle that make up the Ethernet cable (TX+, TX-, RX+, RX-). Another two wires provide 5V and GND to power the 'Wheel' Tivas. The last two wires were used for Emergency Stop purposes - one for a 'Wheel' Tiva to request an E-STOP (from the 'master' Tiva) and one to get back the response. The 'requests' then become two inputs to an AND gate on the 'Omni' PCB. Another two inputs to the AND gate come from the 'Omni' Tiva itself as well as an external Emergency Stop button (which plugs into the two pin JST in the top of Figure 4). If the Delta robot is being run at the same time as the Omni robot, the output of the AND gate travels up (via the 4-pin JST right next to the two-pin E-STOP JST) to the Delta and becomes an input to another AND gate located on <i>its</i> 'master' PCB. The output from the Delta AND gate (i.e. the 'response') travels back down to the 'Omni' PCB then to the 'Wheel' PCBs. However, if the Delta robot is not connected, the output of the AND gate located on the 'Omni' PCB becomes the 'response' signal (thus, the reason why the 4-pin JST shows a wire looping back on itself - note that the other two pins of that JST do not connect to anything). Finally, the black FTDI cable shown in Figure 4 connects to a USB port in the NUC.
    </p>
    <p>Besides for the 'Omni' FTDI cable, three other micro-USB cables plug into the NUC. One is used to power the 'Omni' Tiva (which then feeds the power to the 'Wheel' Tivas). The other two plug into <a href="https://www.hokuyo-aut.jp/search/single.php?serial=166" target="_blank">this</a> laser scanner and <a href="https://www.digikey.com/product-detail/en/sparkfun-electronics/SEN-14001/1568-1460-ND/6569364" target="_blank">this</a> IMU respectively. To power the NUC though is a bigger problem since it only accepts 12-19VDC and because it should be isolated from the 24V motor power supply. To fix this issue, <a href="https://www.mouser.com/ProductDetail/Cincon/CHB100W-24S15-CM?qs=sGAEpiMZZMvGsmoEFRKS8K1E1cjl%252byI1KuVMoGoVhIfkFKyYYc59Rw%3d%3d" target="_blank">this DC/DC converter</a> was placed between the NUC and the 24V motor power supply (can partially be seen under the 'Omni' PCB in Figure 4). In any event, that about sums up the wiring of the Omni robot!
    </p>
    <h3>Programming the Tiva Microcontroller</h3>
    <p>With an ARM Cortex-M4 core capable of floating point, CPU speeds up to 80 MHz, 256KB Flash memory, 2KB EEPROM, 8 UART modules, 2 Quadrature Encoder Inputs, and a pricetag of only $13.50, the TM4C123G LaunchPad Evaluation Board had everything needed to make this project work. Although in the design from last quarter, the plan was to have each Sabertooth connected to a <a href="https://www.superdroidrobots.com/shop/item.aspx?itemid=1514" target="_blank">Kangaroo motion controller</a> which in turn would be wired to a single Arduino Mega, this was rejected for a couple of reasons. For one, the Kangaroo (which would have been responsible for doing PID control to maintain the desired wheel speeds) could not accurately measure the velocity of a given motor. For example, if the Kangaroo was commanded to rotate a motor at 60 rpm, an external tachometer would measure a speed of 55 rpm. A possible explanation for this could be due to the nature of the magnetic encoders on the back of each motor. Normally, Channel A and B should have a 90 degree phase shift between them as shown in Figure 5.
    </p>
    <figure style="text-align: center; float: left; font-style: italic; width: 30%; margin-right: 2%">
      <img src="images/encoder_trace.png" style = "width: 100%;">
      <p>Figure 5: Typical Encoder Trace</p>
    </figure>
    <p> However, when measured with an oscilloscope, the traces from the magnetic encoders showed variable phase shifts - some much less than 90 degrees (ex. if the Channel B trace in Figure 5 was shifted a bit more to the left). Considering the fact that the Kangaroo is designed to read traces with 4x encoding, it is possible then that it registered the leading edge of Channel A but missed the leading edge of Channel B since they were too close in time. This is further evidenced by the fact that the Kangaroo can only process 80,000 pulses/sec which is relatively slow compared to the Tiva microcontroller which can process pulses up to 20 MHz (which is fast enough so that even variable phase shifts don't make a difference). For that reason, it was decided to use the Tiva LaunchPads as a replacement for the Kangaroos (also because the Delta was using them). As such, it didn't make sense to keep using the Arduino Mega but rather to use another Tiva as the 'master' of the two 'Wheel' Tivas to keep the architecture consistent (and cheaper!).
    </p>
    <p>To actually program the Tiva microcontrollers, the Atom text editor was used in conjunction with the GNU Arm Embedded Toolchain so that programs could be flashed to them. In addition, my advisor (Matthew Elwin) provided libraries containing custom Serial communication protocols and basic peripheral initialization functions that he wrote (originally for the Delta robot) for my partner (Aamir Hussain) and I to use while developing our code. For the first couple weeks of the quarter, we both familiarized ourselves with his code as well as his style of programming so that we could program the microcontrollers for the Omni robot in a similar fashion. Additionally, in order to keep communication between the NUC, microcontrollers, and motors straightforward, it was decided to only allow 'upstream' systems to initiate contact. Specifically, the NUC could send commands down to the 'Omni' Tiva which in turn could send commands down to the 'Wheel' Tivas which in turn could send commands to the motors. However, a 'Wheel' Tiva would not be allowed to send data to the 'Omni' Tiva without first being requested to do so by the 'Omni' Tiva. Likewise, the 'Omni' Tiva would not be able to send data to the NUC without the NUC first requesting it. In any event, after becoming familiar with the microcontrollers, I focused on programming the 'Wheel' Tivas - specifically setting up the QEI peripherals mentioned above, creating a library of functions to interface with the Sabertooths (via packetized serial mode described <a href="https://www.dimensionengineering.com/datasheets/Sabertooth2x25v2.pdf" target="_blank">here</a>), and implementing a PID control loop to set wheel speeds. On the other hand, Aamir focused on programming the 'Omni' Tiva - specifically figuring out how to send Serial commands to both 'Wheel' Tivas at the same time as well as implementing functions to convert wheel velocities into twists and visa versa. This will be discussed more in the next couple paragraphs.
    </p>
    <p>In the process of determining the number of encoder ticks per wheel revolution, the following points were observed.
    </p>
    <ul>
        <li>There are 19 pulses per encoder wheel revolution.</li>
        <li>Although Superdroid specifies that the gear reduction ratio of the motors is <a href="https://www.superdroidrobots.com/shop/item.aspx?itemid=843" target="_blank">12:1</a>, it is in fact 12.25:1. Thus, it takes 12.25 encoder wheel revolutions to rotate the motor output shaft just once.</li>
        <li>The gear reduction ratio from the sprocket on the output motor shaft to the sprocket on the wheel axle is 21:15. Thus, for every 21 rotations of the output motor shaft, the actual wheel of the robot rotates 15 times.</li>
        <li>The microcontroller uses x4 encoding so each pulse of the encoder is counted as 4 indivdiual ticks (rising edge of Channel A, rising edge of Channel B, falling edge of Channel A, falling edge of Channel B) which increases resolution by a factor of 4.</li>
    </ul>
    <p>Therefore, the number of ticks counted by the QEI peripheral on the Tiva that make up one wheel revolution is: $$ \frac{19\,pulses}{1\,encoder\,wheel\,rev} * \frac{12.25\,encoder\,wheel\,rev}{1\,motor\,rev} * \frac{21\,motor\,rev}{15\,wheel\,rev} * \frac{4\,ticks}{1\,pulse}= \frac{1303.4\,ticks}{1\,wheel\,rev} $$ To convert from ticks/rev to the angular velocity units of rad/sec, the following points were considered.</p>
    <ul>
        <li>The system clock frequency for the Tiva was set to 80 MHz.</li>
        <li>The QEI peripheral has an associated API (found in the TivaWare Peripheral Driver Library <a href="http://www.ti.com/lit/ug/spmu298d/spmu298d.pdf" target="_blank">here</a>) that allows the user to count the number of encoder ticks per a given period of time (measured in system clock ticks). Currently, this value is set to 1.6 million.</li>
    </ul>
    <p>This then leads to the conversion equation below: $$ \frac{x\,ticks}{1.6\,million\,system\,ticks} * \frac{80\,million\,system\,ticks}{1\,sec} * \frac{1\,rev}{1303.4\,ticks} * \frac{2\pi}{1\,rev} = \frac{y\,rad}{sec} $$ Using this equation and PID control, the 'Wheel' Tiva was able to complete its purpose - to get a pair of desired wheel velocities (in rad/sec) from the 'Omni' Tiva, command both motors to achieve those speeds, and send back to the 'Omni' Tiva the current wheel speeds for odometry purposes. Besides for this, the 'Wheel' Tiva was also programmed with functions to change PID values and to save/load them to and from EEPROM.
    </p>
    <figure style="text-align: center; float: right; font-style: italic; width: 30%; margin-left: 2%">
      <img src="images/mecanum_kinematics.png" style = "width: 100%;">
      <p>Figure 6: Mecanum Wheel Kinematics (pg. 519 in Modern Robotics)</p>
    </figure>
    <p>Once all four wheel velocities are sent to the 'Omni' Tiva, the next step is to calculate the planar twist of the robot. This can be done using Equation 13.33 from <i>Modern Robotics</i>: $$ V_b = Fu \qquad => \qquad \begin{bmatrix} w_{bz} \\ v_{bx} \\ v_{by} \end{bmatrix} = \frac{r}{4} \begin{bmatrix} \frac{-1}{(l+w)} & \frac{1}{(l+w)} & \frac{1}{(l+w)} & \frac{-1}{(l+w)} \\ 1 & 1 & 1 & 1 \\ -1 & 1 & -1 & 1 \end{bmatrix} \begin{bmatrix} u_1 \\ u_2 \\ u_3 \\ u_4 \end{bmatrix} $$ where \(u\) is the vector of wheel velocities (the numbers in the subscript correspond to the ones in Figure 6), \(F\) represents the transformation matrix (\(l\), \(w\), and \(r\) correspond to the measurements shown in Figure 6 and the radius of the wheels), and \(V_b\) symobizes the body twist of the robot. With a little rearranging, the equation above can also convert body twists to wheel velocities as shown in Equation 13.10. $$ u = H(0) V_b \qquad => \qquad \begin{bmatrix} u_1 \\ u_2 \\ u_3 \\ u_4 \\ \end{bmatrix} = \frac{1}{r} \begin{bmatrix} -l-w & 1 & -1 \\l+w & 1 & \;\;\;1 \\l+w & 1 & -1 \\-l-w & 1 & \;\;\;1 \\ \end{bmatrix} \begin{bmatrix} w_{bz} \\ v_{bx} \\ v_{by} \\ \end{bmatrix} $$ where \(H^\dagger(0) = F\). Armed with this equation, the 'Omni' Tiva contains functions allowing the NUC to set a desired twist or get a current twist. By sending the commanded wheel velocities to each 'Wheel' Tiva in a piecemeal manner (switching off sending a few bytes to one, then the other), the 'Omni' Tiva also ensured that both wheels would be set to their new velocities at the exact same time. Furthermore, it should be noted that the 'Wheel' Tiva's control loop operated at 400 Hz while the 'Omni' Tiva's control loop ran at 100 Hz. As such, for those 3 - 4 cycles of the control loop that the 'Wheel' Tiva did not hear from the 'Omni' Tiva, it continued to do PID conrol based on the last wheel velocities that were sent. If for some reason, the 'Wheel' Tiva did not hear from the 'Omni' Tiva for more than 100 of its control loop cycles, it would automatically stop the wheels.
    </p>
    <h3>Physical Design &amp; Sensor Placement</h3>
    <figure style="text-align: center; font-style: italic;">
      <img src="images/omni_guts.JPG" style = "width: 70%;">
      <p>Figure 7: Inside of the Omni Robot</p>
    </figure>
    <p>Just like before, I will explain the construction of the Omni robot from the bottom up. After unpackaging, the aluminum chassis already had holes for the ball bearings (2 per axle), upper deck supports (2 per corner), cover (3 evenly spaced per rib), motor output shaft (1 per motor), <a href="https://www.superdroidrobots.com/shop/item.aspx?itemid=2376" target="_blank">motor spacer plate</a> (4 per motor), and oval shaped screwdriver holes (2 per motor). In addition to that, 9 additional holes were drilled towards the front and back of the robot to screw down the Sabertooth driver (4 holes), the 'Wheel' PCB (4 holes) and the 6.3A slow fuse (1 hole). To make it easier to drill these holes in the correct spots, a wooden stencil was laser cut with the correct hole placement. Two more holes were drilled on either side of the robot (in the middle) where ESD drag chains were installed to dissipate static (without them, the robot would accumulate static while driving and shock anyone who touched it). Finally, 5 holes were drilled in the front of the robot to accomodate the Hokuyo laser scanner (3 in the middle to hold a 90 degree aluminum bracket and 1 on either side to hold the U-bolt scanner guard). Regarding hardware, only <a href="https://www.fastenal.com/products/fasteners/sockets/socket-cap-screws?r=~%7Ccategoryl1:%22600000%20Fasteners%22%7C~%20~%7Ccategoryl2:%22600039%20Sockets%22%7C~%20~%7Ccategoryl3:%22600040%20Socket%20Cap%20Screws%22%7C~%20~%7Csattr03:%5E%22Alloy%20Steel%22$%7C~%20~%7Csattr09:%5E%22Black%20Oxide%22$%7C~" target="_blank">Imperial hex drive steel socket cap screws</a> were used although metric ones were installed on the motor spacer plates (since the holes were made specifically for M5 screws). This decision was made so that the builder would only have to use one type of driver (in this case, a set of Imperial Allen wrenches) and because the Delta robot had the same type of screws. Additionally, it would have been difficult to adjust the motor spacer plate with a conventional (ex. Phillips) screw as the drive chain would have been in the way of the screwdriver. The allen wrench however, could be maneuvered around the drive chain to tighten or loosen a socket screw easily.
    </p>
    <figure style="text-align: center; float: left; font-style: italic; width: 30%; margin-right: 2%">
      <img src="images/key_shaft.JPG" style = "width: 100%;">
      <p>Figure 8: Keyed shaft in wheel axle</p>
    </figure>
    <p>To prevent the sprocket on the motor output shaft from slipping, both the shaft and the sprocket were 'D' shaped. Furthermore, all sprockets were installed with set screws that could be tightened to prevent lateral slippage. The sprockets and axle by the wheels however, were keyed as shown in Figure 8. To cut the drive chain to the proper length, a dremmel with a 'grind' top was used, and the procedure outlined in the video at the bottom of <a href="https://www.superdroidrobots.com/shop/item.aspx?itemid=2444" target="_blank">this page</a> was followed. In addition, to connect the B+/B- screw terminals on each Sabertooth to 24V, 18 AWG 2 conductor stranded wire was installed with 15A Anderson connectors at the ends. These connectors were then stuck through a small hole in the back of the cover (between the two switches in Figure 9) to click into their counterparts (the red wire leading to the switch and the black wire leading to the GND rail of the busbar). As can be seen in both Figure 9 and 10, another pair of 15A Anderson connectors linked the input of the isolated DC/DC converted (underneath the 'Omni' Tiva) to 24V as well. From a design perspective, the Anderson adapters were chosen due to the easiness of their use, their ability to withstand tremendous current, and to be consistent with the Delta robot where they were also installed. Adding these connectors also helped make the robot more modular. This was especially helpful in the case of the batteries which could be detached from the rest of robot for charging purposes (30A Anderson connectors were used for this purpose).
    </p>
    <figure style="text-align: center; float: left; font-style: italic; width: 49%; margin-right: 1%">
      <img src="images/omni_back.JPG" style = "width: 100%;">
      <p>Figure 9: Back of the Omni Robot</p>
    </figure>
    <figure style="text-align: center; float: right; font-style: italic; width: 49%; margin-left: 1%">
      <img src="images/omni_top.JPG" style = "width: 100%;">
      <p>Figure 10: Top of the Omni Robot</p>
    </figure>
    <p>Besides for the 6.3A slow fuse by each Sabertooth, there was also a 35A 'system wide' fuse placed between the batteries and the busbar (left part of Figure 9). Additionally, a second switch was placed on the back panel of the robot to power the Delta arm when it will eventually sit on the Omni's upper deck (the first switch obviously powers the Omni robot itself). Lastly, the big red button on the back panel is the Emergency Stop and the object immediately to its right is the Razor IMU. Originally, the IMU was going to be placed at the front of the robot behind the laser scanner, but the magnetic field created by the NUC distorted its magnetometer readings. Fortunately, there was no disturbance observed at the IMU's current location on the back panel.
    </p>
    <p>Moving to the front of the robot, the black square object in Figure 10 represents the Intel NUC computer. Right next to it is a circular hole that allows for the two Ethernet cables originating from the 'Wheel' PCBs to connect to the 'Omni' PCB. Finally, next to that is the DC/DC converter with the 'Omni' PCB ontop, held in place by standoffs. It should be noted that the NUC, DC/DC converter, and 'Omni' PCB are screwed down to a transparent 1/4 inch thick piece of acrylic. This modular 'front deck' was laser cut with all the holes in the correct places to hold the items mentioned above. In turn, the acrylic piece was fastened to the aluminum cover in four places, two of which went through the front rib shown in Figure 7 (thus, the reason for the two holes shown there). Finally, a bracket was placed ontop of the batteries to prevent them from shifting and the upper deck snugly laid down on the four corner supports.
    </p>
    <h3>Single Robot Control</h3>
    <p>Now that the 'Omni' Tiva is capable of sending and recieving individual twists, it was time to create a ROS node to automate the process (initially, this meant commanding a hard coded twist at 100 Hz). Specifically, the node would be responsible for sending the desired twist to the 'Omni' Tiva, recieve the observed twist from the 'Omni' Tiva, and calculate odometry of the robot. To do that, Equations 13.35, 13.36 and a modified version of 13.33 from <i>Modern Robotics</i> were used. It is important to note though that the equations assume that the wheel speeds remain constant between one observed twist and the next (approximately 10ms in this case). In Equation 13.33, the only change is to multiply the right hand side by \(\Delta t\) so that the body twist \(V_b\) is integrated for the right amount of time giving \(V_b = Fu \Delta t\). Next, the difference in coordinates (\(q_b\)) of the robot's new pose relative to its initial pose (before integration) can be found with Equation 13.35. Assuming that \(w_{bz} = 0\), then the change in pose is straightforward. $$ if \; w_{bz}=0, \qquad \Delta q_b = \begin{bmatrix} \Delta \phi _b \\ \Delta x_b \\ \Delta y_b \\ \end{bmatrix} = \begin{bmatrix} 0 \\ v_{bx} \\ v_{by} \\ \end{bmatrix} $$
    However, if \(w_{bz}\) is nonzero, then the integration must also take into account the robot's rotation as it calculates \(\Delta x_b\) and \(\Delta y_b\). $$ if \; w_{bz} \neq 0, \qquad \Delta q_b = \begin{bmatrix} \Delta \phi _b \\ \Delta x_b \\ \Delta y_b \\ \end{bmatrix} = \begin{bmatrix} w_{bz} \\ (v_{bx}\sin w_{bz} + v_{by}(\cos w_{bz} - 1))/w_{bz} \\ (v_{by}\sin w_{bz} + v_{by}(\cos w_{bz} - 1))/w_{bz} \\ \end{bmatrix} $$ At this point, we have calculated the change in pose relative to the robot's initial position before integration. However, even if \(w_{bz}=0\), this change in configuration must be transformed into the world frame {\(s\)} so that it can be added to the current odometry estimate. This can be done as follows. $$ \Delta q = \begin{bmatrix} 1 & 0 & 0 \\ 0 & \cos \phi _k & - \sin \phi _k \\ 0 & \sin \phi _k & \cos \phi _k \\ \end{bmatrix} \Delta q_b $$ where \(\phi _k\) is the previous chassis angle relative to the world frame {\(s\)}. Finally, the new odometry estimate can be computed. $$ q_{k+1} = q_k + \Delta q $$
    </p>
    <figure style="text-align: center; float: right; font-style: italic; width: 30%; margin-left: 2%">
      <img src="images/ps3.jpg" style = "width: 100%;">
      <p>Figure 11: PS3 Controller</p>
    </figure>
    <p>With that out of the way, the next step was to send variable twists to the robot. To do that, a Bluetooth enabled PS3 controller (Figure 11) was used. Specifically, the left stick manipulated sideways motion, the right stick manipulated the forward/backward motion and the R2\L2 buttons manipulated clockwise/counterclockwise motion. Besides for this being a logical user interface, another reason these buttons were used was because they were all analog (values ranging from -1 to 1). For this to work with the robot, a new node was created to subscribe to the PS3 messages, stick the correct analog values into a twist message, and send the message to the main node (called 'omni_node') where it would then be commanded to the robot's wheels. While this worked, it sometimes made the robot move in a jerky manner, especially if it was commanded to go from a total standstill to 0.5m/s in one command (or visa versa). To compensate for this, a 'twist filter' was implemented that would allow the robot to slowly build up or decelerate to the desired speed. It would do this by first normalizing the desired twist if one of its values exceeded a velocity limit. Then, it would calculate and send out a new twist based on a user defined acceleration limit. To incorporate this step, the PS3 node would publish a raw twist to the 'raw' filter topic, recieve the updated twist from the 'smooth' filter topic, and then publish the twist (using a custom message as will be explained later) to the 'omni_node'.
    </p>
    <p>Until now, I have been a big vague as to which nodes are run on which computers so as not to confuse the reader. However, this section will clear that up. First, all three robot NUCs are wirelessly connected to a LAN called 'Boeing' (without WAN). In addition, a 'master' computer is connected to this network as well although this could be done via Ethernet so that the 'master' retains access to Wifi. 
    </p>
